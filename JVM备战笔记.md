对象的内存布局：分为3个区域：对象头实例数据，对齐填充。
一.对象头：1.对象自身的运行时数据。2.类型指针，指向类元数据的指针。
二.实例数据：是对象真正存储的有效信息。
三.对齐数据：对象起始地址必须是8bit的整数倍，若不是，则填充。对齐填充不是必然存在的。

对象的访问定位：句柄访问和直接指针访问。
JAVA分为栈和堆。
Java程序需要通过栈上了reference数据来操作堆上的具体对象。

类加载机制：描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

类的生命周期：加载->验证->准备->解析->初始化->使用->卸载。
(其中的验证->准备->解析称为"连接")

在Java语言里，**类型的加载、连接和初始化过程属于类加载**，都是在程序运行期间完成的。

其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由"类加载器"来实现的。

ClassLoader.getSystemClassLoader()方法直接获取负责加载用户类路径（classpath）上的指定类库的应用程序类加载器（Application ClassLoader）

类加载器分为：启动类加载器（Bootstrap ClassLoader）<-其他类加载器<-扩展类加载器（Extension ClassLoader）<-应用程序类加载器（Application ClassLoader）

类加载器的工作模式：双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。

# JAVA的内存区域

![img](https://user-gold-cdn.xitu.io/2018/12/16/167b69d428db8f2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 程序计数器

* 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。
* 每条线程都有一个独立的程序计数器,此区域为：线程私有内存。
* 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。
* 此内存区域没有规范`OutOfMemoryError`情况

### Java虚拟机栈

* 位于线程私有内存，生命周期与线程相绑定。
* 当线程请求的栈深度大于虚拟机允许的深度，将抛出`StackOverFlowError`异常。
* 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常。
* Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法执行的同时会创建一个**栈帧**。

#### 栈帧

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

##### 局部变量表

* 是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。
* 最小单位为变量槽(Slot)：一个Slot 可以存放一个32位以内的数据类型。

> 包括基本数据类型 (boolean、byte、char、short、int、float、long、double)「**String 是引用类型**」，对象引用 (reference 类型) 和 returnAddress 类型（它指向了一条字节码指令的地址）。

### 本地方法栈

* 本地方法栈为虚拟机使用到的 Native 方法服务。
* 同虚拟机栈相同，Java 虚拟机规范对这个区域也规定了两种异常情况`StackOverflowError`和 `OutOfMemoryError`异常。

### 堆

GC堆

### 方法区

* 用于存储已经被虚拟机加载的**类信息** 、**常量** 、**静态变量**、**即时编译器编译后的代码等数据**
* 运行时常量池 (Runtime Constant Pool) 是方法区的一部分。
* 当方法区无法满足内存分配需求时, 将抛出 `OutOfMemoryError` 异常。

#### 运行时常量池

* Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期生成的字面量和符号引用，都存放于运行时常量池

> **字面量**
>
> 比较接近 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。

> **符号引用**
>
> 符号引用就是字符串，这个字符串包含足够的信息，以供实际使用时可以找到相应的位置。

* 除了保存 Class 文件中描述的符号引用外，还会把编译出来的**直接引用**也存储在运行时常量池中。

### 

# ==垃圾收集算法==

### 一.标记-清除算法

#### 原理

“标记”和“清除”两个阶段

1. 首先标记出所有需要回收的对象。

2. 在标记完成后统一回收所有被标记的对象。

#### 不足

效率不高，耗时比较长；并且会**产生大量内存碎片**，容易提前触发另一次垃圾收集动作。

### 二.复制算法

#### 原理

目的： 为了解决效率问题。

描述：将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

#### 不足

**将内存缩小为了原来的一半。**

### 三.标记-整理算法

#### 原理

目的：解决当复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低的问题。

描述：标记过程仍然与”标记-清除“算法一样，但后续是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

### ==四.分代收集算法==

#### 原理

描述：将JAVA堆分为新生代和老年代。（还有元数据区在本地内存，大小由系统决定。）

##### 新生代

采用**复制收集算法**，将新生代分为一个Eden空间和两块较小的Survivor空间，比例8：1：1。
描述：首先，把E和SF区域中存活的对象复制到ST区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代），同时把这些对象的年龄+1（如果ST不够位置了就放到老年区）；然后，清空E和SF中的对象；最后，SF和ST互换，原SF成为下一次GC时的ST区。

##### 老年代

采用**“标记-清除”或“标记-整理”算法**。

描述：扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。然后对内存碎片进行合并或者标记出来方便下次直接分配

**Minor GC**:指发生在新生代的垃圾收集动作，该动作非常频繁。

**Full GC/Major GC**:指发生在老年代的垃圾收集动作，出现了Major GC，经常会先伴随着执行至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。

### JVM判断对象是否过期的方法

#### 一、引用计数法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。
ps：主流的JVM里面没有选用引用计数算法来管理内存，原因是它很难解决对象间的互循环引用的问题。

#### 二、可达性分析算法

通过一些列的称为“`GCRoots`”的对象作为起始点，向下搜索，搜索所走过的路径称为引用链。当一个对象没有和任何引用链项链时，就证明对象不可用。

`GCRoots`：

1. 虚拟机栈中(栈帧中的本地变量表)引用的对象

2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

# Java引用

强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）四种

### 强引用

强引用还存在，垃圾收集器永远不会回收掉被引用的对象。类似“Object obj = new Object()”

### 软引用

 用来描述有用但并非必须的对象。除非系统要发生OOM，否则都不会回收。

### 弱引用

用户描述非必须对象的。只能生存到下一次垃圾收集发生之前。无论内存是否足够，都会回收。

### 虚引用

一个对象是否有虚引用存在，完全不会对其生存时间构成影响。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。




