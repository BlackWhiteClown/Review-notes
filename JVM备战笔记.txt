对象的内存布局：分为3个区域：对象头实例数据，对齐填充。
一.对象头：1.对象自身的运行时数据。2.类型指针，指向类元数据的指针。
二.实例数据：是对象真正存储的有效信息。
三.对齐数据：对象起始地址必须是8bit的整数倍，若不是，则填充。对齐填充不是必然存在的。

对象的访问定位：句柄访问和直接指针访问。
JAVA分为栈和堆。
Java程序需要通过栈上了reference数据来操作堆上的具体对象。

类加载机制：描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

类的生命周期：加载->验证->准备->解析->初始化->使用->卸载。
(其中的验证->准备->解析称为"连接")

在Java语言里，**类型的加载、连接和初始化过程属于类加载**，都是在程序运行期间完成的。

其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由"类加载器"来实现的。

ClassLoader.getSystemClassLoader()方法直接获取负责加载用户类路径（classpath）上的指定类库的应用程序类加载器（Application ClassLoader）

类加载器分为：启动类加载器（Bootstrap ClassLoader）<-其他类加载器<-扩展类加载器（Extension ClassLoader）<-应用程序类加载器（Application ClassLoader）

类加载器的工作模式：双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。

垃圾收集算法。

一.标记-清除算法：“标记”和“清除”两个阶段
1.首先标记出所有需要回收的对象。
2.在标记完成后统一回收所有被标记的对象。
不足：效率不高，耗时比较长；并且会产生大量内存碎片，容易提前触发另一次垃圾收集动作。

二.复制算法：
目的： 为了解决效率问题。
描述：将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
缺点： 将内存缩小为了原来的一半。

三：标记-整理算法：
目的：解决当复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低的问题。
描述：标记过程仍然与”标记-清除“算法一样，但后续是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

四.分代收集算法
描述：将JAVA堆分为新生代和老年代。（还有元数据区在本地内存，大小由系统决定。）

新生代：采用复制收集算法，将新生代分为一个Eden空间和两块较小的Survivor空间，比例8：1：1。
描述：首先，把E和SF区域中存活的对象复制到ST区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代），同时把这些对象的年龄+1（如果ST不够位置了就放到老年区）；然后，清空E和SF中的对象；最后，SF和ST互换，原SF成为下一次GC时的ST区。

老年代：采用“标记-清除”或“标记-整理”算法。
描述：扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。然后对内存碎片进行合并或者标记出来方便下次直接分配

Minor GC:指发生在新生代的垃圾收集动作，该动作非常频繁。

Full GC/Major GC:指发生在老年代的垃圾收集动作，出现了Major GC，经常会先伴随着执行至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。

JVM判断对象是否过期的方法：

一、引用计数法：
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。
ps：主流的JVM里面没有选用引用计数算法来管理内存，原因是它很难解决对象间的互循环引用的问题。

二、可达性分析算法：
通过一些列的称为“GCRoots”的对象作为起始点，向下搜索，搜索所走过的路径称为引用链。当一个对象没有和任何引用链项链时，就证明对象不可用。

Java引用：强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）四种

强引用：强引用还存在，垃圾收集器永远不会回收掉被引用的对象。类似“Object obj = new Object()”

软引用： 用来描述有用但并非必须的对象。除非系统要发生OOM，否则都不会回收。

弱引用：用户描述非必须对象的。只能生存到下一次垃圾收集发生之前。无论内存是否足够，都会回收。

虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。


枚举类。
1.每一个枚举值是 static final的。
2.每一个枚举值可以有若干个属性。
3.每个枚举值拥有各自的内部方法！
4.枚举类型都隐式继承了java.lang.Enum类，因此不能继承其他类，但可以实现接口；
5.枚举类型只能有私有private的构造方法。
6.枚举类默认实现了Comparable接口和Serializable接口。
例如：
public enum Day {
 MONDAY(1, "星期一", "各种不在状态"){
        @Override
        public Day getNext() {
            return TUESDAY;
        }
    },
    TUESDAY(2, "星期二", "依旧犯困"){
        @Override
        public Day getNext() {
            return WEDNESDAY;
        }
    }；
 Day(int index, String name, String value) {
        this.index = index;
        this.name = name;
        this.value = value;
    }

    private int index;
    private String name;
    private String value;
    public abstract Day getNext();

    。。JAVABEAN方法。。

}

Enum类重写了Object类的四个方法：finalize，hashCode, clone，equal方法，加了final，不让子类重写：

1.finalize：由于枚举类的实例被static final变量强引用，所以不可被垃圾回收，所以重写没有意义。

2.hashCode：枚举类的实例是不变的，不需要重写。

3.equal：枚举类的实例是不变的，所以直接用==判断是否相等就可以了。

4.clone：枚举类的实例不可被克隆。


重载：方法名字相同，而参数一定要不同。返回类型可以相同也可以不同。可以改变访问修饰符。

lambda表达式：
语法:
1.首先是参数列表，这个参数列表与要实现的方法的参数列表一致，用()圆括号括住（当只有一个参数时也可以省略圆括号，但是当没有形参时圆括号不可以省略）（可以省略形参类型）
2.接下来是一个->符号，用于分隔形参列表与函数体，不允许省略。
3.代码体，用{}大括号括住。(如果代码体只有一行代码,可以省略掉花括号,如果方法有返回值,连return关键词都可以省略，系统会自动将这一行代码的结果返回。)

lambda表达式的类型必须是函数式接口 Functional Interface，函数式接口代表有且只有一个抽象方法，但是可以包含多个默认方法或类方法的接口。

注释@FunctionalInterface用来判别函数式接口。

lambda表达式提供了四种引用方法和构造器的方式：
1.引用对象的方法 类::实例方法
2.引用类方法 类::类方法
3.引用特定对象的方法 特定对象::实例方法
4.引用类的构造器  类::new
（系统会自动将函数式接口实现的方法的所有参数中的第一个参数作为调用者，接下来的参数依次传入引用的方法）

Stream API：能够对集合对象进行各种串行或并发聚集操作。